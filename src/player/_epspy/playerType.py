## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName
    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

class _ARRW:
     def __init__(self, obj, index):
         self.obj = obj
         self.index = index
     def __lshift__(self, r):
         self.obj[self.index] = r

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 7) function getCurrentUnitType(epd) {
@EUDFunc
def f_getCurrentUnitType(epd):
    # (Line 9) if(dwread_epd(epd + (0x60 / 4)) >= 10000) return 2;
    if EUDIf()(f_dwread_epd(epd + (0x60 // 4)) >= 10000):
        EUDReturn(2)
        # (Line 10) else return 1;
    if EUDElse()():
        EUDReturn(1)
        # (Line 11) }
    EUDEndIf()
    # (Line 19) function applyUnitTypeChange(player, epd) {

@EUDFunc
def f_applyUnitTypeChange(player, epd):
    # (Line 21) const w1, b0, b1 = dwbreak(dwread_epd(epd + (0x114 / 4)))[[1, 2, 3]];
    _t1 = _SRET(f_dwbreak(f_dwread_epd(epd + (0x114 // 4))), [1, 2, 3])
    w1, b0, b1 = List2Assignable([_t1])
    # (Line 22) const stimTimer = b1;
    stimTimer = b1
    # (Line 23) if(stimTimer >= 1) {
    if EUDIf()(stimTimer >= 1):
        # (Line 25) dwwrite_epd(epd + (0x114 / 4), w1 * 65536 + b0);
        # (Line 28) var shield = dwread_epd(epd + (0x60 / 4));
        f_dwwrite_epd(epd + (0x114 // 4), w1 * 65536 + b0)
        shield = EUDVariable()
        shield << (f_dwread_epd(epd + (0x60 // 4)))
        # (Line 29) if(shield >= 10000) shield -= 10000;
        if EUDIf()(shield >= 10000):
            shield.__isub__(10000)
            # (Line 30) else shield += 10000;
        if EUDElse()():
            shield.__iadd__(10000)
            # (Line 31) dwwrite_epd(epd + (0x60 / 4), shield);
        EUDEndIf()
        # (Line 34) SetCurrentPlayer(player);
        f_dwwrite_epd(epd + (0x60 // 4), shield)
        # (Line 35) PlayWAV("sound\\protoss\\templar\\ptehal01.wav");
        # (Line 36) }
        DoActions([
            SetCurrentPlayer(player),
            PlayWAV("sound\\protoss\\templar\\ptehal01.wav")
        ])
        # (Line 37) }
    EUDEndIf()
    # (Line 43) function applyUnitTypeColor(player, epd) {

@EUDFunc
def f_applyUnitTypeColor(player, epd):
    # (Line 44) const spritePtr = dwread_epd(epd + (0x0C / 4));
    spritePtr = f_dwread_epd(epd + (0x0C // 4))
    # (Line 45) if(!spritePtr) return;
    if EUDIf()(spritePtr, neg=True):
        EUDReturn()
        # (Line 46) if(getCurrentUnitType(epd) == 1) bwrite(spritePtr + 0x0A, player);
    EUDEndIf()
    if EUDIf()(f_getCurrentUnitType(epd) == 1):
        # (Line 47) else bwrite(spritePtr + 0x0A, 138);
        f_bwrite(spritePtr + 0x0A, player)
    if EUDElse()():
        # (Line 48) }
        f_bwrite(spritePtr + 0x0A, 138)
    EUDEndIf()
