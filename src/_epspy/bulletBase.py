## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName
    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

class _ARRW:
     def __init__(self, obj, index):
         self.obj = obj
         self.index = index
     def __lshift__(self, r):
         self.obj[self.index] = r

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 1) import location as loc;
import _epspy.location as loc
# (Line 4) function getNextGeneratedUnit() {
@EUDFunc
def f_getNextGeneratedUnit():
    # (Line 5) return dwepdread_epd(EPD(0x628438));
    EUDReturn(f_dwepdread_epd(EPD(0x628438)))
    # (Line 6) }
    # (Line 9) function makeUnitStackable(epd) {

@EUDFunc
def f_makeUnitStackable(epd):
    # (Line 10) dwwrite_epd(
    # (Line 11) epd + (0xDC / 4),
    # (Line 12) dwread_epd(epd + (0xDC / 4)) | 0x200000
    # (Line 13) );
    _t1 = f_dwwrite_epd(epd + (0xDC // 4), f_dwread_epd(epd + (0xDC // 4)) | 0x200000)
    # (Line 14) }
    _t1
    # (Line 18) function createBullet(unitType, player, speed, x, y) {

@EUDFunc
def f_createBullet(unitType, player, speed, x, y):
    # (Line 19) loc.moveLocationPx($L('mSource'), x, y);
    # (Line 20) const ptr, epd = getNextGeneratedUnit();
    loc.f_moveLocationPx(GetLocationIndex('mSource'), x, y)
    ptr, epd = List2Assignable([f_getNextGeneratedUnit()])
    # (Line 21) if(ptr != 0) {
    if EUDIf()(ptr != 0):
        # (Line 22) CreateUnit(1, unitType, 'mSource', player);
        # (Line 23) makeUnitStackable(epd);
        DoActions(CreateUnit(1, unitType, 'mSource', player))
        # (Line 25) }
        f_makeUnitStackable(epd)
        # (Line 26) return ptr, epd;
    EUDEndIf()
    EUDReturn(ptr, epd)
    # (Line 27) }
    # (Line 31) function shoot(player, unitType, speed, sx, sy, dx, dy) {

@EUDFunc
def f_shoot(player, unitType, speed, sx, sy, dx, dy):
    # (Line 32) const ptr, epd = createBullet(unitType, player, speed, sx, sy);
    ptr, epd = List2Assignable([f_createBullet(unitType, player, speed, sx, sy)])
    # (Line 33) if(ptr != 0) {
    if EUDIf()(ptr != 0):
        # (Line 36) SetMemoryEPD(epd + (0x4C / 4), SetTo, player + 0x00000600);
        # (Line 39) SetMemoryEPD(epd + (0x50 / 4), SetTo, 228);
        # (Line 42) SetMemoryEPD(epd + (0x58 / 4), SetTo, dy * 0x10000 + dx);
        # (Line 43) SetMemoryEPD(epd + (0x5C / 4), SetTo, 0);
        # (Line 44) }
        DoActions([
            SetMemoryEPD(epd + (0x4C // 4), SetTo, player + 0x00000600),
            SetMemoryEPD(epd + (0x50 // 4), SetTo, 228),
            SetMemoryEPD(epd + (0x58 // 4), SetTo, dy * 0x10000 + dx),
            SetMemoryEPD(epd + (0x5C // 4), SetTo, 0)
        ])
        # (Line 45) }
    EUDEndIf()
